<HTML>
<HEAD>
<TITLE>Home Page for ATS</TITLE>
<META name="description" content="Home Page for ATS">
<META name="keywords" content="">
<LINK REL="stylesheet" HREF="ATS.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#E7CF9E" TEXT="#000000" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
<TABLE WIDTH="100%" BORDER=0 CELLSPACING=0 CELLPADDING=10>
<TR>
<TD CLASS="sidebar">&nbsp;</TD>
<TD CLASS="main">&nbsp;</TD>
</TR>

<TD CLASS="sidebar" VALIGN="top">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=2>
  <TR><TD CLASS="menu"><B CLASS="here">Home</B></TD></TR>
  <TR><TD CLASS="menu"><A HREF="TUTORIAL/tutorial.html">Tutorial</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="EXAMPLE/example.html">Examples</A>&nbsp;(<A HREF="EXAMPLE/example_new.html">new</A>)</TD></TR>
  <TR><TD CLASS="menu"><A HREF="IMPLEMENTATION/implementation.html">Implementation</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="RESOURCE/resource.html">Resources</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="LIBRARY/library.html">Libraries</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="PAPER/paper.html">Papers</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="CHANGELOG/changelog.html">ChangeLog</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="FAQ.txt">FAQ</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="https://lists.sourceforge.net/lists/listinfo/ats-lang-users">Mailing List</A></TD></TR>
</TABLE>
</TD>

<TD CLASS="main" VALIGN="top">
<TABLE BORDER=0 CELLPADDING=16>
<CENTER>
<H1>ATS -- unleashing the potential of types!</H1>
<!--
<H3>A programming language with a soul in its type system</H3>
<H3>A language to make typeful programming real and fun</H3>
<H3>A language to support practical programming with theorem proving</H3>
-->
</CENTER>

<HR SIZE=2 ALIGN=LEFT COLOR="000000"><P>

<MENU>
<LI> <A href="#what_is_ats">What is ATS?</A>

<LI> <A href="#what_is_ats_good_for">What is ATS good for?</A>

<LI> <A href="#acknowledgments">Acknowledgments</A>

<LI> <A href="#download_and_installation">Download and Installation</A>:
The current <B>stable</B> release is <a href="http://sourceforge.net/projects/ats-lang/download">ats-lang-anairiats-0.2.1</a> (2.3MB)

<LI> <A href="#simple_ats_programs">Some Simple ATS Programs</A>
</MENU>

<HR SIZE=2 ALIGN=LEFT COLOR="000000"><P>

<MENU>
<LI><H3><A id="what_is_ats" name="what_is_ats">What is <EM>ATS</EM>?</A></H3>
ATS is a programming language with a highly
expressive type system rooted in the framework <EM>Applied Type
System</EM>.  In particular, both dependent types and linear types are
available in ATS.  The current implementation of ATS (ATS/Anairiats) is
written in ATS itself. It can be as efficient as C/C++ (see <A
HREF="http://shootout.alioth.debian.org/">The Computer Language Benchmarks
Game</A> for concrete evidence) and supports a variety of programming
paradigms that include:
<P>
<UL>

<LI><B>Functional programming</B>.
While ATS is primarily a language based on eager (aka. call-by-value)
evaluation, it also supports lazy (aka. call-by-need) evaluation. The
availability of linear types in ATS can often make functional programs in
ATS not only run with surprisingly high efficiency (when compared to C) but
also run with surprisingly small (memory) footprint (when compared to C as
well).
<P>

<!--
<LI>Object-oriented programming
<P>
-->

<LI><B>Imperative programming</B>.  The novel and unique approach to
imperative programming in ATS is firmly rooted in the paradigm of
<EM>programming with theorem proving</EM>. While features considered
dangerous in other languages (e.g., explicit pointer arithmetic and
explicit memory allocation/deallocation) are allowed in ATS, the type
system of ATS is still able to guarantee that no run-time errors can occur
that may lead to memory corruption.
<P>

<LI><B>Concurrent programming</B>. ATS, equipped with a multicore-safe
implementation of garbage collection, can support multithreaded programming
through the use of pthreads. There is also high-level support in ATS for
parallel let-binding, which provides a simple and effective means to
constructing programs that can take advantage of multicore architectures.
<P>

<LI><B>Modular programming</B>. The module system of ATS is largely
infuenced by that of Modula-3, which is both simple and general as well as
effective in supporting large scale programming.
<P>

<!--
<LI>Meta programming (available)
<LI>Assembly programming (planned)
-->
</UL>
<P>
In addition, ATS contains a component ATS/LF that supports a form of
(interactive) theorem proving, where proofs are constructed as total
functions.  With this component, ATS advocates a programming style that
combines programming with theorem proving. Furthermore, this component may
be used as a logical framework to encode various deduction systems and
their (meta-)properties.
<P>

<LI><H3><A id="what_is_ats_good_for" name="what_is_ats">What is
<EM>ATS</EM> good for?</A></H3>
<MENU>
<LI>
ATS allows the programmer to write efficient functional programs by
taking advantage of native unboxed data representation.

<LI>
ATS allows the programmer to reduce the memory footprint of a program
by making use of linear types.

<LI>
ATS allows the programmer to enhance the safety (and efficiency) of a
program by making use of theorem proving.

<LI>
ATS allows the programmer to write safe low-level code that runs in OS
kernels.

<LI>
ATS can help teach type theory, allowing students to see
first-handedly how advanced types such as dependent types and linear types
can be effectively employed in practical programming.
</MENU>
<P>

<LI><H3><A id="acknowledgments"
name="acknowledgments">Acknowledgments</A></H3> The development of ATS has
been funded in part by <a href="http://www.nsf.gov">National Science
Foundation</a> under the grants no. CCR-0081316/CCR-0224244,
no. CCR-0092703/0229480, no. CNS-0202067 and no. CCF-0702665. As always,
<em>any opinions, findings, and conclusions or recommendations expressed
here are those of the author(s) and do not necessarily reflect the views of
the National Science Foundation.</em>
<P>
Many people worked on ATS in the past. The names of some of these people
are included in the following list:
<P>
Chiyan Chen, Sa Cui, Matthew Danish, Kevin Donnelly, Rick Lavoie, Likai Liu, Michel Machado, Rui Shi, Hongwei Xi, Dengping Zhu
<P>

<!--
<LI><H3>Mailing List</H3> Here is the current <A
href="http://types.bu.edu/mailman/listinfo/ats">mailing-list</A> for ATS
users.

<LI><H3>Mailing List</H3>
The mailing-list for ATS users is available <A
HREF="https://lists.sourceforge.net/lists/listinfo/ats-lang-users">
here</A>.
<P>
-->

<LI><H3><A id="download_and_installation">Download and
Installation</A></H3> ATS is <A href="http://www.opensource.org">Open
Source</A> and <A href="http://www.gnu.org/philosophy/free-sw.html">Free
Software</A>, and it is freely available under the GNU GENERAL PUBLIC
LICENSE version 3 (<A href="http://www.gnu.org/licenses/gpl-3.0.html">GPL
3.0</A>) as is published by the Free Software Foundation.  The current
implementation of ATS is given the name ATS/Anairiats or simply Anairiats.
<P>

<H4>Requirements</H4>
In order to install ATS, the following requirements need
to be met:

<MENU>
<LI>Operating System requirement: ATS is supported under the following
operating systems:
<UL>
<LI>Linux
<LI>Windows with Cygwin
<LI>MacOS X (currently no GC support for multithreading)
<LI>SunOS (currently no GC support for multithreading)
<LI>BSD Unix (currently no GC support for multithreading)
</UL>

<LI>Programming Language requirement: GNU C Compiler (GCC).
</MENU>
<P>
We plan to port ATS to other platforms in the future. If you have succeeded
in porting ATS to a platform not listed here, please drop us a note.
<P>
The GMP library (libgmp.a), which is in general included in a GNU/Linux
distribution, is currently <em>optional</em> and it may be required for
installing a release of ATS in the future.  Please see <a
href="http://gmplib.org">http://gmplib.org</a> for more details on GMP.
<P>

<H4>Installation from a precompiled package</H4>

<MENU>
This installation method currently only supports the following platforms:
<P>
<UL>
<LI>Linux on i386 (x86-32)
<LI>Linux on AMD64 (x86-64)
<LI>SunOS on UltraSparc
</UL>
<P>
Please first download a compressed tarball containing a precompiled release of
ATS from the following site that suits your platform:<P> <CENTER> <a
href="http://sourceforge.net/projects/ats-lang/download">http://sourceforge.net/projects/ats-lang/download</a>
</CENTER>
<P>
Let "x.x.x" be the version number of the downloaded ATS package.
<P>

(<B>METHOD 1</B>) You can untar the tarball in the root directory "/" and
then set the shell environment variables ATSHOME and ATSHOMERELOC to
"/usr/share/atshome" and "ATS-x.x.x", respectively. This method most likely
requires root access.
<P>
(<B>METHOD 2</B>) You can untar the tarball in the directory "/tmp", and
then move the directory "/tmp/usr/share/atshome" into a directory of your
choice, say, "FOO", and then set the environment variables ATSHOME and
ATSHOMERELOC to "FOO/atshome" and "ATS-x.x.x", repectively. In
addition, you need to put "$ATSHOME/bin" on your execution path or create
symbolic links to the executables $ATSHOME/bin/atscc and
$ATSHOME/bin/atsopt in a directory that is already on your execution path.
<P>
</MENU>

<H4>Installation through source code compilation</H4>

<MENU>
<LI><H4>Step 1:</H4>
After downloading a compressed tarball containing a release of
ATS from the following site:<P>
<CENTER>
<a href="http://sourceforge.net/projects/ats-lang/download">http://sourceforge.net/projects/ats-lang/download</a>
</CENTER>
<P>
please untar it in a directory, say "FOO", of your choice. This, for
instance, can be done by executing the following command line:

<pre>tar -zvxf ATS.tar.gz </pre>

All the files and directories extracted from the tarball are now in the
directory "FOO/ATS".

<LI><H4>Step 2:</H4>
Please execute the following command

<pre>./configure --prefix=DESTDIR</pre>

where DESTDIR is the name of the directory where ATS is to be installed.

If the argument [--prefix=DESTDIR] is missing, then the default directory
for installing ATS is "/usr/local".

You can now go into the directory "FOO/ATS" and execute

<pre>make all</pre>

This generates executables "atscc" and "atsopt" in the directory
"FOO/ATS/bin", which are the commands you need for compiling ATS programs,
and a library file "libats.a" in the directory "FOO/ATS/CCOMP/lib", which
you need for linking.

<LI><H4>Step 3:</H4>
Please set the environment variable ATSHOME to "FOO/ATS" and then set the
environment variable ATSHOMERELOC to "ATS-x.x.x", where x.x.x is the version
number of the compiled ATS package.

<LI><H4>Step 4:</H4>

Optionally, you may install ATS by executing the following
command line:

<pre>make install</pre>

and then set ATSHOME to $DESTDIR/share/ats-anairiats-x.x.x, which is the
name of the directory where ATS is installed. The environment variable
ATSHOMERELOC is still set to "ATS-x.x.x".

<P>

<!--
Lastly, please make sure that the environment variable ATSHOME is set to
the name of the directory in which ATS is installed, and the environment
variable ATSHOMERELOC is set to ATS-x.x.x, where x.x.x is the verison
number of ATS package. This should probably be done by a shell script.
Note that the values of ATSHOME and ATSHOMERELOC can be found in the files
"FOO/ATS/.ATSHOME" and "FOO/ATS/.ATSHOMERELOC", respectively.
<P>
-->

</MENU>

<H4>Installation through bootstrapping</H4> This installation method is
probably the best if you would like to keep abreast of the development of ATS.
Please find more details <A HREF="IMPLEMENTATION/implementation.html">here</A>.

<!-- end of [#download_and_installation] -->

<LI><H3><A id="simple_ats_programs" name="simple_ats_programs">Some Simple ATS Programs</A></H3>
Let us now construct and compile some simple ATS programs.

<H4>Hello, world!</H4> In a file named
<a href="EXAMPLE/INTRO/HelloWorld.dats">HelloWorld.dats</a>,
we write the following lines of code

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// compilation command:
</FONT><FONT COLOR="#787878">//   atscc -o HelloWorld HelloWorld.dats
</FONT>
<FONT COLOR="#000000">implement</FONT> main <FONT COLOR="#000000">()</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">begin</FONT>
  print <FONT COLOR="#000000">(</FONT>"Hello, world!"<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> print_newline <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT>
<FONT COLOR="#000000">end</FONT>
</FONT></PRE>

By executing the following command line, we produce an excutable file named
"HelloWorld":

<PRE>atscc -o HelloWorld HelloWorld.dats</PRE>

What happens here is that <i>atscc</i> first compiles

<a href="EXAMPLE/INTRO/HelloWorld.dats">HelloWorld.dats</a>

into

<a href="EXAMPLE/INTRO/HelloWorld_dats.c">HelloWorld_dats.c</a>,

which is then compiled by gcc to produce "HelloWorld".  By running
"HelloWorld", we can see the following line on the standard output:

<PRE>Hello, world!</PRE> 

<H4>Factorial (version 1)</H4> A simple recursive function <i>fact1</i>
is defined as follows to compute factorials.

<PRE><FONT COLOR="#E800000"><FONT COLOR="#787878">// [fun] declares a recursive function
</FONT><FONT COLOR="#000000">fun</FONT> fact1 <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">if</FONT> x <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> x * fact1 <FONT COLOR="#000000">(</FONT>x-1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> 1
</FONT></PRE>

The following code passes an integer read from the standard input to the
function <i>fact1</i> and then prints the result returned from
<i>fact1</i> onto the standard output.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// [fn] declares a non-recursive function; it is fine to replace [fn] with [fun]
</FONT><FONT COLOR="#787878">// [@(...)] is used in ATS to group arguments for functions of variable arguments
</FONT><FONT COLOR="#000000">fn</FONT> fact1_usage <FONT COLOR="#000000">(</FONT>cmd<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">string</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
  prerrf <FONT COLOR="#000000">(</FONT>"Usage: %s [integer]\n"<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">@(</FONT>cmd<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#787878">// print an error message</FONT>

<FONT COLOR="#000000">implement</FONT> main <FONT COLOR="#000000">(</FONT>argc<FONT COLOR="#000000">,</FONT> argv<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">if</FONT> argc &gt;= 2 <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> n <FONT COLOR="#000000">=</FONT> int1_of argv<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT>1<FONT COLOR="#000000">]</FONT> <FONT COLOR="#787878">// turning a string into an integer
</FONT>    <FONT COLOR="#000000">val</FONT> res <FONT COLOR="#000000">=</FONT> fact1 n
  <FONT COLOR="#000000">in</FONT>
    printf <FONT COLOR="#000000">(</FONT>"factorial of %i = %i\n"<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">@(</FONT>n<FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
    fact1_usage <FONT COLOR="#000000">(</FONT>argv<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT>0<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> exit <FONT COLOR="#000000">(</FONT>1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

Note that the function <i>exit</i> is given the following type:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// [a:viewt@ype] means that [a] can be a linear type of any size
</FONT><FONT COLOR="#000000">fun</FONT> exit <FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>a<FONT COLOR="#000000">:</FONT>viewt@ype<FONT COLOR="#000000">}</FONT> int <FONT COLOR="#000000">-&gt;</FONT> a</FONT>
</FONT></PRE>

Also note that the type <i>void</i> should not be confused with the type
<i>unit</i> in languages like SML and OCaml; the former is of size 0 while
the latter is of size 1 (word).
<P>

The entire code for this example is available <a href="EXAMPLE/INTRO/fact1.dats">here</a>.

<H4>Factorial (version 2)</H4>

Let us now see an example involving dependent types.  In ATS, <i>int</i> is
a static constant of the following sort:

<PRE>int -&gt; type</PRE>

Note that the symbol <i>int</i> is overloaded: it is both a static constant
and a sort. Given an integer
<i>i</i> (of sort <i>int</i>), <i>int(i)</i> is a singleton type
containing only the integer <i>i</i>. So <i>int</i> is often called a
type constructor. We now define a
type constant <i>Int</i> as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">typedef</FONT> <FONT COLOR="#0000FF">Int <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">:</FONT>int<FONT COLOR="#000000">]</FONT> int n</FONT> <FONT COLOR="#787878">// type for integers
</FONT></FONT></PRE>

We use the syntax <i>[n:int]</i> to existentially quantify over
some variable <i>n</i> of sort <i>int</i>, that is, <i>n</i>
ranging over integers.

We define the type for natural number as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">typedef</FONT> <FONT COLOR="#0000FF">Nat <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">[</FONT>n<FONT COLOR="#000000">:</FONT>int <FONT COLOR="#000000">|</FONT> n &gt;= 0<FONT COLOR="#000000">]</FONT> int n</FONT> <FONT COLOR="#787878">// type for natural numbers</FONT>
</FONT></PRE>

where the syntax <i>[n:int | n &gt;= 0]</i> represents existential
quantification over some variable <i>n</i> of sort <i>int</i> that
satisfies <i>n &gt;= 0</i>.
<P>
The factorial function can be implemented as follows:

<PRE><FONT COLOR="#E80000"><FONT COLOR="#000000">fun</FONT> fact2 <FONT COLOR="#0000FF"><FONT COLOR="#000000">{</FONT>n<FONT COLOR="#000000">:</FONT>nat<FONT COLOR="#000000">}</FONT></FONT> <FONT COLOR="#000000">(</FONT>x<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">int n</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">Nat</FONT> <FONT COLOR="#000000">=</FONT> <FONT COLOR="#000000">if</FONT> x <FONT COLOR="#000000">&gt;</FONT> 0 <FONT COLOR="#000000">then</FONT> x nmul fact2 <FONT COLOR="#000000">(</FONT>x-1<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">else</FONT> 1
</FONT></PRE>

The type assigned to <i>fact2</i> indicates that the function returns a
natural number when applied to a natural number. It causes a type error
if <i>fact2</i> is applied to a negative integer. The function
<i>nmul</i> (infix) is assumed to be of the following type:

<PRE>(Nat, Nat) -&gt; Nat</PRE>

That is, <i>nmul</i> returns a natural number when applied to
two natural numbers.

The following code indicates the necessity to check that an integer read
from the standard input is nonngative when <i>fact2</i> is called on it.
In particuar, eliminating such a check results in a type error when the
code is typechecked.

<PRE><FONT COLOR="#E80000"><FONT COLOR="#787878">// [fn] declares a non-recursive function
</FONT><FONT COLOR="#787878">// [@(...)] is used in ATS to group arguments for functions of variable arguments
</FONT><FONT COLOR="#000000">fn</FONT> fact2_usage <FONT COLOR="#000000">(</FONT>cmd<FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">string</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">:</FONT> <FONT COLOR="#0000FF">void</FONT> <FONT COLOR="#000000">=</FONT>
  prerrf <FONT COLOR="#000000">(</FONT>"Usage: %s [integer]\n"<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">@(</FONT>cmd<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#787878">// print an error message</FONT>

<FONT COLOR="#000000">implement</FONT> main <FONT COLOR="#000000">(</FONT>argc<FONT COLOR="#000000">,</FONT> argv<FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT>
  <FONT COLOR="#000000">if</FONT> argc &gt;= 2 <FONT COLOR="#000000">then</FONT> <FONT COLOR="#000000">let</FONT>
    <FONT COLOR="#000000">val</FONT> n <FONT COLOR="#000000">=</FONT> int1_of argv<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT>1<FONT COLOR="#000000">]</FONT> <FONT COLOR="#787878">// turning a string into an integer
</FONT>    <FONT COLOR="#000000">val</FONT> <FONT COLOR="#000000">(</FONT><FONT COLOR="#000000">)</FONT> <FONT COLOR="#000000">=</FONT> assert_errmsg
      <FONT COLOR="#000000">(</FONT>n &gt;= 0<FONT COLOR="#000000">,</FONT> "The integer argument needs to be nonnegative.\n"<FONT COLOR="#000000">)</FONT>
    <FONT COLOR="#000000">val</FONT> res <FONT COLOR="#000000">=</FONT> fact2 n
  <FONT COLOR="#000000">in</FONT>
    printf <FONT COLOR="#000000">(</FONT>"factorial of %i = %i\n"<FONT COLOR="#000000">,</FONT> <FONT COLOR="#000000">@(</FONT>n<FONT COLOR="#000000">,</FONT> res<FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT> <FONT COLOR="#000000">else</FONT> <FONT COLOR="#000000">begin</FONT>
    fact2_usage <FONT COLOR="#000000">(</FONT>argv<FONT COLOR="#000000">.</FONT><FONT COLOR="#000000">[</FONT>0<FONT COLOR="#000000">]</FONT><FONT COLOR="#000000">)</FONT><FONT COLOR="#000000">;</FONT> exit <FONT COLOR="#000000">(</FONT>1<FONT COLOR="#000000">)</FONT>
  <FONT COLOR="#000000">end</FONT>
</FONT></PRE>

The entire code for this example is available <a
href="EXAMPLE/INTRO/fact2.dats">here</a>. One may want to see what happens
to typechecking if the call to <i>assert_errmsg</i> in the code is deleted.

<H4>Factorial (version 3)</H4>

If you are not afraid of being overwhelmed at this moment, please find an
implementation of the factorial function <a
href="EXAMPLE/INTRO/fact3.dats">here</a> that bears the signature of ATS:
<EM>programming with theorem proving</EM>.  This is an implementation of
the factorial function whose correctness is formally verified in the type
system of ATS.

<H4>List Quicksort</H4> This one is for program verification enthusiasts:
An implementation of list quicksort is given <a
href="EXAMPLE/MISC/listquicksort_dats.html">here</a> that guarantees solely
based on its type that the implmentation is terminating and the output list
it returns is always a <EM>sorted permutation</EM> of its input list.  This
is considered a milestone example in the development of ATS.

<H4>A GTK/cairo Clock</H4> A clock implementation based on <a
href="http://www.gtk.org">GTK+</a> and <a
href="http://www.cairographics.org">cairo</a> is available <a
href="EXAMPLE/GTK/gtkcairoclock_dats.html">here</a>, which demonstrates
some simple and effective use of linear types in ATS for tracking
resources statically, that is, at compile-time.

<H4>More Examples</H4> Please find more, more advanced and larger, examples
<a href="EXAMPLE/example.html">here</a>.
<P>

<LI><H3><A HREF="RESOURCE/resource.html">Resources for Programming in
ATS</A></H3> Please follow the link to find the User's Guide on
ATS/Anairiats, an Emacs mode for ATS, a variety of contributed code, and
more.
<P>

</MENU>

<HR SIZE=6 ALIGN=LEFT><P>
This page is maintained by
<a href="http://www.cs.bu.edu/~hwxi">Hongwei Xi</a>.
As always,
<a href="mailto:hwxi@cs.bu.edu">your comments are welcome</a>.

<HR SIZE=6 ALIGN=LEFT>
<a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2" align=right width="125" height="37" border="0" alt="SourceForge.net Logo"/></a>

</TABLE>
</TD>

</BODY>
</HTML>
