(*
** Wavefront OBJ file loader.
** Written by Artyom Shalkhakov in June, 2011.
*)

%{
(* ****** ****** *)
//
// preamble
//
staload _ = "prelude/DATS/array.dats"
staload _ = "prelude/DATS/list_vt.dats"

staload "libats/SATS/rarray.sats"
staload _ = "libats/DATS/rarray.dats"

staload "libats/lex/lexing.sats"

staload "libc/SATS/stdio.sats"

(* ****** ****** *)

staload "obj.sats"

(* ****** ****** *)

dataviewtype token =
  | TOKint of int
  | TOKfl of float
  | TOKnl // newline
  | TOKsl // slash
  | TOKv | TOKvn | TOKvt | TOKf
  | TOKeof
// end of [token]

fun free_token .< >. (tok: token):<> void = case+ tok of
  | ~TOKint _ => ()
  | ~TOKfl _ => ()
  | ~TOKnl () => ()
  | ~TOKsl () => ()
  | ~TOKv () => ()
  | ~TOKvn () => ()
  | ~TOKvt () => ()
  | ~TOKf () => ()
  | ~TOKeof () => ()
// end of [free_token]

extern fun fprint_token {m:file_mode}
  (pf_mod: file_mode_lte (m, w) | fil: &FILE m, tok: !token): void

implement fprint_token
  (pf_mod | fil, tok) = case+ tok of
  | TOKint i =>
      (fprint_int (pf_mod | fil, i); fold@ tok)
  | TOKfl f =>
      (fprint_float (pf_mod | fil, f); fold@ tok)
  | TOKnl () =>
      (fprint_string (pf_mod | fil, "NL"); fold@ tok)
  | TOKsl () =>
      (fprint_string (pf_mod | fil, "SL"); fold@ tok)
  | TOKv () =>
      (fprint_string (pf_mod | fil, "TOKv"); fold@ tok)
  | TOKvn () =>
      (fprint_string (pf_mod | fil, "TOKvn"); fold@ tok)
  | TOKvt () =>
      (fprint_string (pf_mod | fil, "TOKvt"); fold@ tok)
  | TOKf () =>
      (fprint_string (pf_mod | fil, "TOKf"); fold@ tok)
  | TOKeof () =>
      (fprint_string (pf_mod | fil, "TOKeof"); fold@ tok)
// end of [fprint_token]

extern fun print_token (tok: !token): void

implement print_token (tok) = let
  val (pf_stdout | stdout) = stdout_get ()
in
  fprint_token (file_mode_lte_w_w | !stdout, tok);
  stdout_view_set (pf_stdout | (*none*))
end // end of [print_token]

extern fun prerr_token (tok: !token): void

implement prerr_token (tok) = let
  val (pf_stderr | stderr) = stderr_get ()
in
  fprint_token (file_mode_lte_w_w | !stderr, tok);
  stderr_view_set (pf_stderr | (*none*))
end // end of [prerr_token]

(* ****** ****** *)

%{^

extern long int
strtol (const char *nptr, char **endptr, int base) ;

ats_int_type __strtoi
  (ats_ptr_type str, ats_int_type base) {
  return strtol ((char*)str, (char**)0, base) ;
} // end of [__strtoi]

ats_float_type __strtod
  (ats_ptr_type str) {
  return strtod ((char*)str, (char**)0) ;
} // end of [__strtoi]

%}

fun lexeme_int (): int = let
  val str = lexeme_string () in __strtoi (str, 10)
end where {
  extern fun __strtoi (str: string, base: int): int = "__strtoi"
}

fun lexeme_float (): float = let
  val str = lexeme_string () in __strtod (str)
end where {
  extern fun __strtod (str: string): float = "__strtod"
}

(* ****** ****** *)

extern fun TOKEN (): token
fn TOKEN_lexing_error {a:viewt@ype} (): a = lexing_error ()

fn process_illegal_token {a:viewt@ype} (): a = begin
  prerr_string ": LEXING ERROR";
  prerr_string ": illegal character [";
  prerr_char (lexeme_get 0);
  prerr_string "] at position [";
  lexing_curpos_prerr ();
  prerr_string "].";
  prerr_newline ();
  $raise LexingErrorException
end // end of [process_illegal_token]

(* ****** ****** *)

%}

// definition of constants of regular expressions

blank = [ ' ' '\t' '\f' ]+

digit = [ '0'-'9' ]

literal_int = ['-']? $digit+

exp = ['e' 'E'] ['+' '-']? $digit+
ufloat0 = $digit+ $exp
ufloat1 = $digit+ '.' $digit* ($exp)?

ufloat = $ufloat0 | $ufloat1
// ufloat = $ufloat0 | $ufloat2
literal_float = ['-']? $ufloat

ident = ['a'-'z' 'A'-'Z']['a'-'z' 'A'-'Z' '0'-'9' '.']*

com = ['#'] [^ '\n']* ['\n']

%%

TOKEN () =
  | $blank { TOKEN () }
  | $com { TOKEN () }
  | "\n" { TOKnl () }
  | "/" { TOKsl () }
  | "v" { TOKv () }
  | "vt" { TOKvt () }
  | "vn" { TOKvn () }
  | "m" { TOKEN () }
  | "mtllib" { TOKEN () }
  | "o" { TOKEN () }
  | "u" { TOKEN () }
  | "g" { TOKEN () }
  | "f" { TOKf () }
  | $ident { TOKEN () }
  | $literal_int { TOKint (lexeme_int ()) }
  | $literal_float { TOKfl (lexeme_float ()) }
  | [^] { process_illegal_token () }
  | $EOF { TOKeof () }


%%

%{^
#include "libc/CATS/stdio.cats"
%} // end of [%{^]

// postamble in the obj.lats
exception ParseError

(* ****** ****** *)

fun parse_error {a:viewt@ype} (s: string): a = begin
  prerr s; prerr ": [";
  lexing_curpos_prerr ();
  prerr "]\n";
  $raise ParseError
end // end of [parse_error]

fun skip_newline (tok: &token): void = case+ tok of
  | ~TOKnl () => tok := TOKEN ()
  | tok_v => (tok := tok_v; parse_error "expected newline")
// end of [skip_newline]

fun parse_float (tok: &token): float = case+ tok of
  | ~TOKfl f => (tok := TOKEN (); f)
  | ~TOKint i => (tok := TOKEN (); float_of i)
  | tok_v => (tok := tok_v; parse_error "expected float")
// end of [parse_float]

fun parse_size (tok: &token): size_t = case+ tok of
  | ~TOKint s => (tok := TOKEN (); size_of_int s)
  | tok_v => (tok := tok_v; parse_error "expected unsigned int")
// end of [parse_size]

fun parse_float2 (tok: &token): float2_t = let
  val a = parse_float tok
  val b = parse_float tok
in
  @(a, b)
end // end of [parse_float2]

fun parse_float3 (tok: &token): float3_t = let
  val a = parse_float tok
  val b = parse_float tok
  val c = parse_float tok
in
  @(a, b, c)
end // end of [parse_float3]

fun parse_size3 (tok: &token): size3_t = let
  val a = parse_size tok
  val b = parse_size tok
  val c = parse_size tok
in
  @(a, b, c)
end // end of [parse_size3]

(* ****** ****** *)

viewtypedef listsz_vt (a:viewt@ype, n:int) = @(size_t n, list_vt (a, n))

#define cons list_vt_cons
#define nil list_vt_nil

fun{a:viewt@ype} listsz_cons {n:nat} .< >. (
  l: &listsz_vt (a, n) >> listsz_vt (a, n+1), x: a
) :<> void = begin
  l.0 := l.0 + 1;
  l.1 := cons (x, l.1)
end // end of [listsz_cons]

viewtypedef meshconstr (nv:int, nn:int, ntc:int, nf:int) = @{
  verts= listsz_vt (float3_t, nv)
, norms= listsz_vt (float3_t, nn)
, texcoords= listsz_vt (float2_t, ntc)
, faces= listsz_vt (triangle, nf)
}
viewtypedef meshconstr = [nv,nn,ntc,nf:nat] meshconstr (nv, nn, ntc, nf)

(* ****** ****** *)

typedef parsemesh_type = (
  &token, &meshconstr >> meshconstr (nv', nn', ntc', nf')
) -<fun1> #[nv',nn',ntc',nf':nat] void // end of [parsemesh_type]

(*
[faceidx] := sz | sz/sz | sz//sz | sz/sz/sz
*)

fun parse_faceidx (tok: &token, f: &faceidx): void = case+ tok of
  | ~TOKint sz0 => let // v
      val [sz0:int] sz0 = int1_of_int sz0
      val () = assert_errmsg (sz0 > 0, "[parse_faceidx]: not 1-based!")
      val sz0 = size_of_int (sz0 - 1)
      val () = tok := TOKEN ()
    in
      case+ tok of
      | ~TOKsl () => let // v/
          val () = tok := TOKEN ()
        in
          case+ tok of
          | ~TOKint sz1 => let // v/x, where x is either normal index, or texcoord index
              val [sz1:int] sz1 = int1_of_int sz1
              val () = assert_errmsg (sz1 > 0, "[parse_faceidx]: not 1-based!")
              val sz1 = size_of_int (sz1 - 1)
              val () = tok := TOKEN ()
            in
              case+ tok of
              | ~TOKsl () => let // v/t/
                  val () = tok := TOKEN ()
                in
                  case+ tok of
                  // v//n
                  | ~TOKint sz2 => let
                      val [sz2:int] sz2 = int1_of_int sz2
                      val () = assert_errmsg (sz2 > 0, "[parse_faceidx]: not 1-based!")
                      val sz2 = size_of_int (sz2 - 1)
                    in
                      tok := TOKEN ();
                      f.vidx := sz0;
                      f.tidx := sz1;
                      f.nidx := sz2
                    end // end of [begin]
                  // v/t/_
                  | tok_v => (tok := tok_v; parse_error "expected normal index")
                end // end of [let]
              | tok_v => // v/t
                  (tok := tok_v; f.vidx := sz0; f.tidx := sz1)
            end // end of [let]
          | ~TOKsl () => let // v//
              val () = tok := TOKEN ()
            in
              case+ tok of
              | ~TOKint sz1 => let // v//n
                  val [sz1:int] sz1 = int1_of_int sz1
                  val () = assert_errmsg (sz1 > 0, "[parse_faceidx]: not 1-based!")
                  val sz1 = size_of_int (sz1 - 1)
                  val () = tok := TOKEN ()
                in
                  f.vidx := sz0; f.nidx := sz1
                end // end of [let]
              | tok_v => // v//x
                  (tok := tok_v; parse_error "expected unsigned int")
            end // end of [let]
          | tok_v => (tok := tok_v; parse_error "expected forward slash")
        end // end of [let]
      | tok_v => (tok := tok_v; f.vidx := sz0)
    end // end of [let]
  | tok_v => (tok := tok_v; parse_error "expected unsigned int")
// end of [parse_faceidx]

(*
[tri] := [faceidx] [faceidx] [faceidx]
[face] := [tri] [idxlst]
[idxlst] := [faceidx] [idxlst]
          | // empty
*)

viewtypedef face = [n:nat | n >= 3] list_vt (faceidx, n)

// this function preserves ordering of elements in a list
fun parse_face (
  tok: &token
) : face = let
  fun loop (
      tok: &token
    , res: &List_vt faceidx? >> list_vt (faceidx, m)
    ) : #[m:nat] size_t m = case+ tok of
    | TOKnl () => (fold@ tok; res := nil (); size1_of_int1 0)
    | tok_v => let
        var fidx = @{vidx= size_of_int 0, nidx= size_of_int 0, tidx= size_of_int 0}
        val () = tok := tok_v
        val () = parse_faceidx (tok, fidx)
        val () = res := list_vt_cons {faceidx} {0} (fidx, ?)
        val+ cons (_, !p) = res
        val sz = loop (tok, !p)
      in
        fold@ res; sz + 1
      end // end of [let]
  // end of [loop]
  var res: List_vt faceidx
  val sz = loop (tok, res)
  val () = assert_errmsg (sz >= 3, "[parse_face]: less than three vertices in a face")
in
  res
end // end of [parse_face]

fun triangle_of_face {n:nat} .< >. (
    x: face, ls: &listsz_vt (triangle, n) >> listsz_vt (triangle, m)
  ):<> #[m:nat] void = let
  fun loop {n,k:nat} .<n>. (
      xs: list_vt (faceidx, n)
    , a: faceidx, b: faceidx
    , ls: &listsz_vt (triangle, k) >> listsz_vt (triangle, m)
    ) :<> #[m:nat] void = case+ xs of
    | ~nil () => ()
    | ~cons (c, xss) => let
        val () = listsz_cons (ls, @(a, b, c))
        val () = loop (xss, a, c, ls)
      in
        // nothing
      end // end of [loop]
  val+ ~cons (a, ~cons (b, ~cons(c, rst))) = x
  val () = listsz_cons (ls, @(a, b, c))
in
  loop (rst, a, c, ls)
end // end of [triangle_of_face]

(*
[phrase] :=
  | v flt flt flt
  | vn flt flt flt
  | vt flt flt
  | [f]
*)

extern fun parse_mesh: parsemesh_type
implement parse_mesh (tok, msh) = let
in
  case+ tok of
  | ~TOKv () => begin
      tok := TOKEN ();
      listsz_cons (msh.verts, parse_float3 (tok));
      skip_newline (tok);
      parse_mesh (tok, msh)
    end // end of [begin]
  | ~TOKvn () => begin
      tok := TOKEN ();
      listsz_cons (msh.norms, parse_float3 (tok));
      skip_newline (tok);
      parse_mesh (tok, msh)
    end // end of [begin]
  | ~TOKvt () => begin
      tok := TOKEN ();
      listsz_cons (msh.texcoords, parse_float2 (tok));
      skip_newline (tok);
      parse_mesh (tok, msh)
    end // end of [begin]
  | ~TOKf () => begin
      tok := TOKEN ();
      triangle_of_face (parse_face (tok), msh.faces);
      skip_newline (tok);
      parse_mesh (tok, msh)
    end // end of [begin]
  | TOKnl () => begin // skip newlines
      tok := TOKEN ();
      parse_mesh (tok, msh)
    end // end of [begin]
  | tok_v => tok := tok_v
end // end of [parse_mesh]

(* ****** ****** *)

// initialize from list, but in reverse order (starting from the last
// element of array, ending at the first)
fun{a:viewt@ype} array_ptr_initialize_lst_vt_rev {n:nat} .< >. (
  base: &(@[a?][n]) >> @[a][n], sz: size_t n, xs0: list_vt (a, n)
) :<> void = let
  fun loop {n:nat} {l:addr} .<n>. (
      pf: rarray_v (a?, n, l) | p: ptr l, xs: list_vt (a, n)
    ) :<> (
      rarray_v (a, n, l) | void
    ) = case+ xs of
    | ~list_vt_cons (x, xs) => let
        prval (pf1, pf2) = rarray_v_uncons {a?} (pf)
        val p1 = p - sizeof<a>
        val () = !p1 := x
        val (pf1 | ans) = loop (pf1 | p1, xs)
      in
        (rarray_v_cons {a} (pf1, pf2) | ans)
      end // end of [let]
    | ~list_vt_nil () => let
        prval () = rarray_v_unnil {a?} (pf) in (rarray_v_nil {a} () | ())
      end // end of [let]
  // end of [loop]
  val (pf_mul, pf_rarr | p) = array2rarray_ptr (view@ (base) | &base, sz)
  val (pf_rarr | ()) = loop (pf_rarr | p, xs0)
  prval () = view@ (base) := array_v_of_rarray_v {a} (pf_mul, pf_rarr)
in
  // nothing
end // end of [array_ptr_initialize_lst_vt_rev]

fun mesh_finalize {nv,nn,ntc,nf:nat} (
    msh_in: meshconstr (nv, nn, ntc, nf)
  , msh_out: &mesh0? >> mesh (nv, nn, ntc, nf)
  ) : void = let
  fn{a:t@ype} conv {n:nat} .< >. (
      src: listsz_vt (a, n)
    , dst: &arrsz0_vt a? >> arrsz_vt (a, n)
    ) :<> void = let
    val [l:addr] (pf_gc, pf_arr | p) = array_ptr_alloc<a> src.0
    val () = array_ptr_initialize_lst_vt_rev<a> (!p, src.0, src.1)
    prval () = dst.0 := pf_arr
    prval () = dst.1 := pf_gc
    val () = dst.2 := src.0
    val () = dst.3 := p
  in
  end // end of [conv]
in
  conv (msh_in.verts, msh_out.verts);
  conv (msh_in.norms, msh_out.norms);
  conv (msh_in.texcoords, msh_out.texcoords);
  conv (msh_in.faces, msh_out.faces)
end

(* ****** ****** *)

dynload "libats/lex/lexing.dats"

(* ****** ****** *)

implement mesh_from_file (filename, msh_out) = let
  fun{a:viewt@ype} listsz_init (): listsz_vt (a, 0) =
    @(size1_of_int1 0, list_vt_nil ())
  // end of [listsz_init]
  val (pfopt | p_ifp) = fopen_err (filename, file_mode_r)
in
  if p_ifp > null then let
    prval Some_v (pf) = pfopt
    val (pf_infil | p_infil) = infile_make_file (pf, file_mode_lte_r_r | p_ifp)
    val (pf_lexbuf | lexbuf) = lexbuf_make_infile (pf_infil | p_infil)
    val () = lexing_lexbuf_set (pf_lexbuf | lexbuf)
    var tok: token = TOKEN ()
    var msh = @{
        verts= @(size1_of_int1 0, list_vt_nil ())
      , norms= @(size1_of_int1 0, list_vt_nil ())
      , texcoords= @(size1_of_int1 0, list_vt_nil ())
      , faces= @(size1_of_int1 0, list_vt_nil ())
      } // end of [msh]
    val () = parse_mesh (tok, msh)
    // end of [val]
    val () = (case+ tok of
      | ~TOKeof () => ()
      | tok_v => begin
          print_token tok_v;
          free_token tok_v;
          prerrf ("[mesh_from_file]: couldn't parse [%s]\n", @(filename));
          exit {void} (1)
        end // end of [begin]
    ) : void
    val () = mesh_finalize (msh, msh_out)
    val () = lexing_lexbuf_free ()
  in
    // nothing
  end else let
    prval None_v () = pfopt
    // for the sake of typechecking
    prval () = __cast (msh_out) where {
      extern castfn __cast (m: &mesh0? >> mesh):<> void
    } // end of [prval]
  in
    prerrf ("[mesh_from_file]: can't open [%s]\n", @(filename));
    exit {void} (1)
  end // end of [if]
end // end of [mesh_from_file]

(* ****** ****** *)

implement mesh_free (m) = let
  val+ @{verts= v, norms= n, texcoords= t, faces= f} = m
in
  array_ptr_free (v.1, v.0 | v.3);
  array_ptr_free (n.1, n.0 | n.3);
  array_ptr_free (t.1, t.0 | t.3);
  array_ptr_free (f.1, f.0 | f.3)
end // end of [mesh_free]

(* ****** ****** *)

(* end of [obj.lats] *)
